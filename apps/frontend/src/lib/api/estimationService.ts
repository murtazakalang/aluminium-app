import { api } from '../api';
import { useAuthStore } from '../store/auth-store';
import { API_BASE_URL } from '../config';

export interface EstimationItem {
  productTypeId: string;
  width: number;
  height: number;
  quantity: number;
  itemLabel?: string;
  // NEW: Glass type selection fields
  selectedGlassTypeId?: string;
  selectedGlassTypeNameSnapshot?: string;
  calculatedGlassQuantity?: string | number;
  calculatedGlassUnit?: 'sqft' | 'sqm';
  calculatedGlassCost?: string | number;
}

// Define the interface for individual breakdown items for use in CalculatedMaterial
export interface PipeBreakdownItem {
  length: string | { $numberDecimal: string }; // From Mongoose Decimal128
  unit: string;
  count: number;
  lengthInInches?: number; // Optional field from backend for weight calculations
}

export interface CalculatedMaterial {
  materialId: string;
  materialNameSnapshot: string;
  materialCategorySnapshot: string;
  totalQuantity: string;
  quantityUnit: string;
  totalWeight: string; // Added field for weight calculation
  weightUnit: string; // Added field for weight unit (kg, lb, etc.)
  autoUnitRate: string; // Added field for auto-filled rate
  autoRateUnit: string; // Added field for auto-filled rate unit
  manualUnitRate: string;
  manualRateUnit?: string; // Added optional manualRateUnit
  calculatedCost: string;
  pipeBreakdown?: PipeBreakdownItem[]; // Optional field for profiles
  // NEW: Source tracking for glass materials
  sourceType?: 'profile' | 'hardware' | 'glass';
  sourceItemIds?: string[]; // References to estimation items
}

export interface ManualCharge {
  description: string;
  amount: string;
  // Labour cost metadata
  isLabourCharge?: boolean;
  labourCostType?: 'fixed' | 'perSqft' | 'perSqm' | 'percentage';
  labourRate?: string;
  productTypeId?: string;
  calculatedArea?: string;
  itemQuantity?: number;
  autoGenerated?: boolean;
  manuallyModified?: boolean;
  rateDescription?: string;
}

export interface Estimation {
  _id: string;
  projectName: string;
  clientId?: string | { _id: string; clientName: string; email?: string; /* other fields */ };
  clientNameSnapshot?: string;
  dimensionUnitUsed: 'inches' | 'mm' | 'ft' | 'm';
  items: EstimationItem[];
  calculatedMaterials: CalculatedMaterial[];
  manualCharges: ManualCharge[];
  subtotalMaterials: string;
  subtotalManualCharges: string;
  totalEstimatedCost: string;
  markupPercentage: string;
  markedUpTotal: string;
  status: 'Draft' | 'Calculated' | 'Converted' | 'Archived';
  notes?: string; // Added optional notes
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface EstimationCreateData {
  projectName: string;
  clientId?: string;
  dimensionUnitUsed: 'inches' | 'mm' | 'ft' | 'm';
  items: EstimationItem[];
}

export interface EstimationUpdateData extends EstimationCreateData {
  manualCharges?: ManualCharge[];
  markupPercentage?: string;
  calculatedMaterials?: Partial<CalculatedMaterial>[];
}

export const estimationApi = {
  // Create a new estimation
  createEstimation: async (data: EstimationCreateData): Promise<Estimation> => {
    const response = await api<{ message: string; estimation: Estimation }>('/api/estimations', { 
      method: 'POST', 
      body: data 
    });
    return response.estimation;
  },

  // Get a list of estimations with optional filtering
  getEstimations: async (
    page = 1, 
    limit = 10, 
    status?: string, 
    sortBy = 'createdAt', 
    sortOrder: 'asc' | 'desc' = 'desc'
  ) => {
    const queryParams = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
      sortBy,
      sortOrder,
    });
    
    if (status) {
      queryParams.append('status', status);
    }
    
    return await api<{ 
      estimations: Estimation[],
      pagination: { 
        currentPage: number, 
        totalPages: number, 
        totalEstimations: number 
      } 
    }>(`/api/estimations?${queryParams.toString()}`);
  },

  // Get a specific estimation by ID
  getEstimation: async (id: string): Promise<Estimation> => {
    return await api<Estimation>(`/api/estimations/${id}`);
  },

  // Update an estimation
  updateEstimation: async (id: string, data: EstimationUpdateData): Promise<{ estimation: Estimation; message: string; warning?: string }> => {
    const response = await api<{ message: string; estimation: Estimation; warning?: string }>(`/api/estimations/${id}`, { 
      method: 'PUT', 
      body: data 
    });
    return response;
  },

  // Delete an estimation
  deleteEstimation: async (id: string): Promise<void> => {
    await api<{ message: string }>(`/api/estimations/${id}`, { method: 'DELETE' });
  },

  // Calculate materials for an estimation
  calculateMaterials: async (id: string): Promise<Estimation> => {
    try {
      console.log(`[estimationApi] Calling calculateMaterials for estimation ${id}`);
      const response = await api<{ message: string; estimation: Estimation }>(`/api/estimations/${id}/calculate`, { 
        method: 'POST' 
      });
      
      if (!response || !response.estimation) {
        console.error(`[estimationApi] Invalid response received:`, response);
        throw new Error('Invalid response: missing estimation data');
      }
      
      console.log(`[estimationApi] Successfully calculated materials for estimation ${id}`);
      return response.estimation;
    } catch (error) {
      console.error(`[estimationApi] Error calculating materials for estimation ${id}:`, error);
      throw error;
    }
  },

  // Generate PDF for an estimation
  generatePDF: async (estimationId: string): Promise<Blob> => {
    try {
      const token = useAuthStore.getState().token;
      const response = await fetch(`${API_BASE_URL}/api/estimations/${estimationId}/pdf`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });

      if (!response.ok) {
        throw new Error(`Failed to generate PDF: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      
      return blob;
    } catch (error) {
      throw error;
    }
  },

  // Convert an estimation to a quotation
  convertToQuotation: async (id: string): Promise<{ message: string; quotationId: string }> => {
    return await api<{ message: string; quotationId: string }>(`/api/estimations/${id}/to-quotation`, { 
      method: 'POST' 
    });
  },

  // NEW: Calculate glass for specific item
  calculateGlassForItem: async (estimationId: string, itemId: string) => {
    return await api(`/api/estimations/${estimationId}/calculate-glass?itemId=${itemId}`);
  }
};

export default estimationApi; 